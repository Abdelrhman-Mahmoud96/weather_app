// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'manage_locations_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ManageLocationsEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadPreviousLocations,
    required TResult Function() loadLastUsedLocation,
    required TResult Function(String locationName) searchLocation,
    required TResult Function(Location locationEntity) removeLocation,
    required TResult Function(Location locationEntity) pickPreviousLocation,
    required TResult Function(Location locationEntity, bool isFavorite)
        toggleIsFavoriteLocation,
    required TResult Function(Location locationEntity) addToPreviousLocations,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadPreviousLocations value)
        loadPreviousLocations,
    required TResult Function(LoadLastUsedLocation value) loadLastUsedLocation,
    required TResult Function(SearchLocation value) searchLocation,
    required TResult Function(RemoveLocation value) removeLocation,
    required TResult Function(PickPreviousLocation value) pickPreviousLocation,
    required TResult Function(ToggleIsFavoriteLocation value)
        toggleIsFavoriteLocation,
    required TResult Function(AddToPreviousLocations value)
        addToPreviousLocations,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ManageLocationsEventCopyWith<$Res> {
  factory $ManageLocationsEventCopyWith(ManageLocationsEvent value,
          $Res Function(ManageLocationsEvent) then) =
      _$ManageLocationsEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$ManageLocationsEventCopyWithImpl<$Res>
    implements $ManageLocationsEventCopyWith<$Res> {
  _$ManageLocationsEventCopyWithImpl(this._value, this._then);

  final ManageLocationsEvent _value;
  // ignore: unused_field
  final $Res Function(ManageLocationsEvent) _then;
}

/// @nodoc
abstract class _$$LoadPreviousLocationsCopyWith<$Res> {
  factory _$$LoadPreviousLocationsCopyWith(_$LoadPreviousLocations value,
          $Res Function(_$LoadPreviousLocations) then) =
      __$$LoadPreviousLocationsCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadPreviousLocationsCopyWithImpl<$Res>
    extends _$ManageLocationsEventCopyWithImpl<$Res>
    implements _$$LoadPreviousLocationsCopyWith<$Res> {
  __$$LoadPreviousLocationsCopyWithImpl(_$LoadPreviousLocations _value,
      $Res Function(_$LoadPreviousLocations) _then)
      : super(_value, (v) => _then(v as _$LoadPreviousLocations));

  @override
  _$LoadPreviousLocations get _value => super._value as _$LoadPreviousLocations;
}

/// @nodoc

class _$LoadPreviousLocations implements LoadPreviousLocations {
  const _$LoadPreviousLocations();

  @override
  String toString() {
    return 'ManageLocationsEvent.loadPreviousLocations()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadPreviousLocations);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadPreviousLocations,
    required TResult Function() loadLastUsedLocation,
    required TResult Function(String locationName) searchLocation,
    required TResult Function(Location locationEntity) removeLocation,
    required TResult Function(Location locationEntity) pickPreviousLocation,
    required TResult Function(Location locationEntity, bool isFavorite)
        toggleIsFavoriteLocation,
    required TResult Function(Location locationEntity) addToPreviousLocations,
  }) {
    return loadPreviousLocations();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
  }) {
    return loadPreviousLocations?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
    required TResult orElse(),
  }) {
    if (loadPreviousLocations != null) {
      return loadPreviousLocations();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadPreviousLocations value)
        loadPreviousLocations,
    required TResult Function(LoadLastUsedLocation value) loadLastUsedLocation,
    required TResult Function(SearchLocation value) searchLocation,
    required TResult Function(RemoveLocation value) removeLocation,
    required TResult Function(PickPreviousLocation value) pickPreviousLocation,
    required TResult Function(ToggleIsFavoriteLocation value)
        toggleIsFavoriteLocation,
    required TResult Function(AddToPreviousLocations value)
        addToPreviousLocations,
  }) {
    return loadPreviousLocations(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
  }) {
    return loadPreviousLocations?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
    required TResult orElse(),
  }) {
    if (loadPreviousLocations != null) {
      return loadPreviousLocations(this);
    }
    return orElse();
  }
}

abstract class LoadPreviousLocations implements ManageLocationsEvent {
  const factory LoadPreviousLocations() = _$LoadPreviousLocations;
}

/// @nodoc
abstract class _$$LoadLastUsedLocationCopyWith<$Res> {
  factory _$$LoadLastUsedLocationCopyWith(_$LoadLastUsedLocation value,
          $Res Function(_$LoadLastUsedLocation) then) =
      __$$LoadLastUsedLocationCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadLastUsedLocationCopyWithImpl<$Res>
    extends _$ManageLocationsEventCopyWithImpl<$Res>
    implements _$$LoadLastUsedLocationCopyWith<$Res> {
  __$$LoadLastUsedLocationCopyWithImpl(_$LoadLastUsedLocation _value,
      $Res Function(_$LoadLastUsedLocation) _then)
      : super(_value, (v) => _then(v as _$LoadLastUsedLocation));

  @override
  _$LoadLastUsedLocation get _value => super._value as _$LoadLastUsedLocation;
}

/// @nodoc

class _$LoadLastUsedLocation implements LoadLastUsedLocation {
  const _$LoadLastUsedLocation();

  @override
  String toString() {
    return 'ManageLocationsEvent.loadLastUsedLocation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadLastUsedLocation);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadPreviousLocations,
    required TResult Function() loadLastUsedLocation,
    required TResult Function(String locationName) searchLocation,
    required TResult Function(Location locationEntity) removeLocation,
    required TResult Function(Location locationEntity) pickPreviousLocation,
    required TResult Function(Location locationEntity, bool isFavorite)
        toggleIsFavoriteLocation,
    required TResult Function(Location locationEntity) addToPreviousLocations,
  }) {
    return loadLastUsedLocation();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
  }) {
    return loadLastUsedLocation?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
    required TResult orElse(),
  }) {
    if (loadLastUsedLocation != null) {
      return loadLastUsedLocation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadPreviousLocations value)
        loadPreviousLocations,
    required TResult Function(LoadLastUsedLocation value) loadLastUsedLocation,
    required TResult Function(SearchLocation value) searchLocation,
    required TResult Function(RemoveLocation value) removeLocation,
    required TResult Function(PickPreviousLocation value) pickPreviousLocation,
    required TResult Function(ToggleIsFavoriteLocation value)
        toggleIsFavoriteLocation,
    required TResult Function(AddToPreviousLocations value)
        addToPreviousLocations,
  }) {
    return loadLastUsedLocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
  }) {
    return loadLastUsedLocation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
    required TResult orElse(),
  }) {
    if (loadLastUsedLocation != null) {
      return loadLastUsedLocation(this);
    }
    return orElse();
  }
}

abstract class LoadLastUsedLocation implements ManageLocationsEvent {
  const factory LoadLastUsedLocation() = _$LoadLastUsedLocation;
}

/// @nodoc
abstract class _$$SearchLocationCopyWith<$Res> {
  factory _$$SearchLocationCopyWith(
          _$SearchLocation value, $Res Function(_$SearchLocation) then) =
      __$$SearchLocationCopyWithImpl<$Res>;
  $Res call({String locationName});
}

/// @nodoc
class __$$SearchLocationCopyWithImpl<$Res>
    extends _$ManageLocationsEventCopyWithImpl<$Res>
    implements _$$SearchLocationCopyWith<$Res> {
  __$$SearchLocationCopyWithImpl(
      _$SearchLocation _value, $Res Function(_$SearchLocation) _then)
      : super(_value, (v) => _then(v as _$SearchLocation));

  @override
  _$SearchLocation get _value => super._value as _$SearchLocation;

  @override
  $Res call({
    Object? locationName = freezed,
  }) {
    return _then(_$SearchLocation(
      locationName: locationName == freezed
          ? _value.locationName
          : locationName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SearchLocation implements SearchLocation {
  const _$SearchLocation({required this.locationName});

  @override
  final String locationName;

  @override
  String toString() {
    return 'ManageLocationsEvent.searchLocation(locationName: $locationName)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchLocation &&
            const DeepCollectionEquality()
                .equals(other.locationName, locationName));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(locationName));

  @JsonKey(ignore: true)
  @override
  _$$SearchLocationCopyWith<_$SearchLocation> get copyWith =>
      __$$SearchLocationCopyWithImpl<_$SearchLocation>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadPreviousLocations,
    required TResult Function() loadLastUsedLocation,
    required TResult Function(String locationName) searchLocation,
    required TResult Function(Location locationEntity) removeLocation,
    required TResult Function(Location locationEntity) pickPreviousLocation,
    required TResult Function(Location locationEntity, bool isFavorite)
        toggleIsFavoriteLocation,
    required TResult Function(Location locationEntity) addToPreviousLocations,
  }) {
    return searchLocation(locationName);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
  }) {
    return searchLocation?.call(locationName);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
    required TResult orElse(),
  }) {
    if (searchLocation != null) {
      return searchLocation(locationName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadPreviousLocations value)
        loadPreviousLocations,
    required TResult Function(LoadLastUsedLocation value) loadLastUsedLocation,
    required TResult Function(SearchLocation value) searchLocation,
    required TResult Function(RemoveLocation value) removeLocation,
    required TResult Function(PickPreviousLocation value) pickPreviousLocation,
    required TResult Function(ToggleIsFavoriteLocation value)
        toggleIsFavoriteLocation,
    required TResult Function(AddToPreviousLocations value)
        addToPreviousLocations,
  }) {
    return searchLocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
  }) {
    return searchLocation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
    required TResult orElse(),
  }) {
    if (searchLocation != null) {
      return searchLocation(this);
    }
    return orElse();
  }
}

abstract class SearchLocation implements ManageLocationsEvent {
  const factory SearchLocation({required final String locationName}) =
      _$SearchLocation;

  String get locationName;
  @JsonKey(ignore: true)
  _$$SearchLocationCopyWith<_$SearchLocation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RemoveLocationCopyWith<$Res> {
  factory _$$RemoveLocationCopyWith(
          _$RemoveLocation value, $Res Function(_$RemoveLocation) then) =
      __$$RemoveLocationCopyWithImpl<$Res>;
  $Res call({Location locationEntity});

  $LocationCopyWith<$Res> get locationEntity;
}

/// @nodoc
class __$$RemoveLocationCopyWithImpl<$Res>
    extends _$ManageLocationsEventCopyWithImpl<$Res>
    implements _$$RemoveLocationCopyWith<$Res> {
  __$$RemoveLocationCopyWithImpl(
      _$RemoveLocation _value, $Res Function(_$RemoveLocation) _then)
      : super(_value, (v) => _then(v as _$RemoveLocation));

  @override
  _$RemoveLocation get _value => super._value as _$RemoveLocation;

  @override
  $Res call({
    Object? locationEntity = freezed,
  }) {
    return _then(_$RemoveLocation(
      locationEntity: locationEntity == freezed
          ? _value.locationEntity
          : locationEntity // ignore: cast_nullable_to_non_nullable
              as Location,
    ));
  }

  @override
  $LocationCopyWith<$Res> get locationEntity {
    return $LocationCopyWith<$Res>(_value.locationEntity, (value) {
      return _then(_value.copyWith(locationEntity: value));
    });
  }
}

/// @nodoc

class _$RemoveLocation implements RemoveLocation {
  const _$RemoveLocation({required this.locationEntity});

  @override
  final Location locationEntity;

  @override
  String toString() {
    return 'ManageLocationsEvent.removeLocation(locationEntity: $locationEntity)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RemoveLocation &&
            const DeepCollectionEquality()
                .equals(other.locationEntity, locationEntity));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(locationEntity));

  @JsonKey(ignore: true)
  @override
  _$$RemoveLocationCopyWith<_$RemoveLocation> get copyWith =>
      __$$RemoveLocationCopyWithImpl<_$RemoveLocation>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadPreviousLocations,
    required TResult Function() loadLastUsedLocation,
    required TResult Function(String locationName) searchLocation,
    required TResult Function(Location locationEntity) removeLocation,
    required TResult Function(Location locationEntity) pickPreviousLocation,
    required TResult Function(Location locationEntity, bool isFavorite)
        toggleIsFavoriteLocation,
    required TResult Function(Location locationEntity) addToPreviousLocations,
  }) {
    return removeLocation(locationEntity);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
  }) {
    return removeLocation?.call(locationEntity);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
    required TResult orElse(),
  }) {
    if (removeLocation != null) {
      return removeLocation(locationEntity);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadPreviousLocations value)
        loadPreviousLocations,
    required TResult Function(LoadLastUsedLocation value) loadLastUsedLocation,
    required TResult Function(SearchLocation value) searchLocation,
    required TResult Function(RemoveLocation value) removeLocation,
    required TResult Function(PickPreviousLocation value) pickPreviousLocation,
    required TResult Function(ToggleIsFavoriteLocation value)
        toggleIsFavoriteLocation,
    required TResult Function(AddToPreviousLocations value)
        addToPreviousLocations,
  }) {
    return removeLocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
  }) {
    return removeLocation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
    required TResult orElse(),
  }) {
    if (removeLocation != null) {
      return removeLocation(this);
    }
    return orElse();
  }
}

abstract class RemoveLocation implements ManageLocationsEvent {
  const factory RemoveLocation({required final Location locationEntity}) =
      _$RemoveLocation;

  Location get locationEntity;
  @JsonKey(ignore: true)
  _$$RemoveLocationCopyWith<_$RemoveLocation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PickPreviousLocationCopyWith<$Res> {
  factory _$$PickPreviousLocationCopyWith(_$PickPreviousLocation value,
          $Res Function(_$PickPreviousLocation) then) =
      __$$PickPreviousLocationCopyWithImpl<$Res>;
  $Res call({Location locationEntity});

  $LocationCopyWith<$Res> get locationEntity;
}

/// @nodoc
class __$$PickPreviousLocationCopyWithImpl<$Res>
    extends _$ManageLocationsEventCopyWithImpl<$Res>
    implements _$$PickPreviousLocationCopyWith<$Res> {
  __$$PickPreviousLocationCopyWithImpl(_$PickPreviousLocation _value,
      $Res Function(_$PickPreviousLocation) _then)
      : super(_value, (v) => _then(v as _$PickPreviousLocation));

  @override
  _$PickPreviousLocation get _value => super._value as _$PickPreviousLocation;

  @override
  $Res call({
    Object? locationEntity = freezed,
  }) {
    return _then(_$PickPreviousLocation(
      locationEntity: locationEntity == freezed
          ? _value.locationEntity
          : locationEntity // ignore: cast_nullable_to_non_nullable
              as Location,
    ));
  }

  @override
  $LocationCopyWith<$Res> get locationEntity {
    return $LocationCopyWith<$Res>(_value.locationEntity, (value) {
      return _then(_value.copyWith(locationEntity: value));
    });
  }
}

/// @nodoc

class _$PickPreviousLocation implements PickPreviousLocation {
  const _$PickPreviousLocation({required this.locationEntity});

  @override
  final Location locationEntity;

  @override
  String toString() {
    return 'ManageLocationsEvent.pickPreviousLocation(locationEntity: $locationEntity)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PickPreviousLocation &&
            const DeepCollectionEquality()
                .equals(other.locationEntity, locationEntity));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(locationEntity));

  @JsonKey(ignore: true)
  @override
  _$$PickPreviousLocationCopyWith<_$PickPreviousLocation> get copyWith =>
      __$$PickPreviousLocationCopyWithImpl<_$PickPreviousLocation>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadPreviousLocations,
    required TResult Function() loadLastUsedLocation,
    required TResult Function(String locationName) searchLocation,
    required TResult Function(Location locationEntity) removeLocation,
    required TResult Function(Location locationEntity) pickPreviousLocation,
    required TResult Function(Location locationEntity, bool isFavorite)
        toggleIsFavoriteLocation,
    required TResult Function(Location locationEntity) addToPreviousLocations,
  }) {
    return pickPreviousLocation(locationEntity);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
  }) {
    return pickPreviousLocation?.call(locationEntity);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
    required TResult orElse(),
  }) {
    if (pickPreviousLocation != null) {
      return pickPreviousLocation(locationEntity);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadPreviousLocations value)
        loadPreviousLocations,
    required TResult Function(LoadLastUsedLocation value) loadLastUsedLocation,
    required TResult Function(SearchLocation value) searchLocation,
    required TResult Function(RemoveLocation value) removeLocation,
    required TResult Function(PickPreviousLocation value) pickPreviousLocation,
    required TResult Function(ToggleIsFavoriteLocation value)
        toggleIsFavoriteLocation,
    required TResult Function(AddToPreviousLocations value)
        addToPreviousLocations,
  }) {
    return pickPreviousLocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
  }) {
    return pickPreviousLocation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
    required TResult orElse(),
  }) {
    if (pickPreviousLocation != null) {
      return pickPreviousLocation(this);
    }
    return orElse();
  }
}

abstract class PickPreviousLocation implements ManageLocationsEvent {
  const factory PickPreviousLocation({required final Location locationEntity}) =
      _$PickPreviousLocation;

  Location get locationEntity;
  @JsonKey(ignore: true)
  _$$PickPreviousLocationCopyWith<_$PickPreviousLocation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ToggleIsFavoriteLocationCopyWith<$Res> {
  factory _$$ToggleIsFavoriteLocationCopyWith(_$ToggleIsFavoriteLocation value,
          $Res Function(_$ToggleIsFavoriteLocation) then) =
      __$$ToggleIsFavoriteLocationCopyWithImpl<$Res>;
  $Res call({Location locationEntity, bool isFavorite});

  $LocationCopyWith<$Res> get locationEntity;
}

/// @nodoc
class __$$ToggleIsFavoriteLocationCopyWithImpl<$Res>
    extends _$ManageLocationsEventCopyWithImpl<$Res>
    implements _$$ToggleIsFavoriteLocationCopyWith<$Res> {
  __$$ToggleIsFavoriteLocationCopyWithImpl(_$ToggleIsFavoriteLocation _value,
      $Res Function(_$ToggleIsFavoriteLocation) _then)
      : super(_value, (v) => _then(v as _$ToggleIsFavoriteLocation));

  @override
  _$ToggleIsFavoriteLocation get _value =>
      super._value as _$ToggleIsFavoriteLocation;

  @override
  $Res call({
    Object? locationEntity = freezed,
    Object? isFavorite = freezed,
  }) {
    return _then(_$ToggleIsFavoriteLocation(
      locationEntity: locationEntity == freezed
          ? _value.locationEntity
          : locationEntity // ignore: cast_nullable_to_non_nullable
              as Location,
      isFavorite: isFavorite == freezed
          ? _value.isFavorite
          : isFavorite // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  $LocationCopyWith<$Res> get locationEntity {
    return $LocationCopyWith<$Res>(_value.locationEntity, (value) {
      return _then(_value.copyWith(locationEntity: value));
    });
  }
}

/// @nodoc

class _$ToggleIsFavoriteLocation implements ToggleIsFavoriteLocation {
  const _$ToggleIsFavoriteLocation(
      {required this.locationEntity, required this.isFavorite});

  @override
  final Location locationEntity;
  @override
  final bool isFavorite;

  @override
  String toString() {
    return 'ManageLocationsEvent.toggleIsFavoriteLocation(locationEntity: $locationEntity, isFavorite: $isFavorite)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ToggleIsFavoriteLocation &&
            const DeepCollectionEquality()
                .equals(other.locationEntity, locationEntity) &&
            const DeepCollectionEquality()
                .equals(other.isFavorite, isFavorite));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(locationEntity),
      const DeepCollectionEquality().hash(isFavorite));

  @JsonKey(ignore: true)
  @override
  _$$ToggleIsFavoriteLocationCopyWith<_$ToggleIsFavoriteLocation>
      get copyWith =>
          __$$ToggleIsFavoriteLocationCopyWithImpl<_$ToggleIsFavoriteLocation>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadPreviousLocations,
    required TResult Function() loadLastUsedLocation,
    required TResult Function(String locationName) searchLocation,
    required TResult Function(Location locationEntity) removeLocation,
    required TResult Function(Location locationEntity) pickPreviousLocation,
    required TResult Function(Location locationEntity, bool isFavorite)
        toggleIsFavoriteLocation,
    required TResult Function(Location locationEntity) addToPreviousLocations,
  }) {
    return toggleIsFavoriteLocation(locationEntity, isFavorite);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
  }) {
    return toggleIsFavoriteLocation?.call(locationEntity, isFavorite);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
    required TResult orElse(),
  }) {
    if (toggleIsFavoriteLocation != null) {
      return toggleIsFavoriteLocation(locationEntity, isFavorite);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadPreviousLocations value)
        loadPreviousLocations,
    required TResult Function(LoadLastUsedLocation value) loadLastUsedLocation,
    required TResult Function(SearchLocation value) searchLocation,
    required TResult Function(RemoveLocation value) removeLocation,
    required TResult Function(PickPreviousLocation value) pickPreviousLocation,
    required TResult Function(ToggleIsFavoriteLocation value)
        toggleIsFavoriteLocation,
    required TResult Function(AddToPreviousLocations value)
        addToPreviousLocations,
  }) {
    return toggleIsFavoriteLocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
  }) {
    return toggleIsFavoriteLocation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
    required TResult orElse(),
  }) {
    if (toggleIsFavoriteLocation != null) {
      return toggleIsFavoriteLocation(this);
    }
    return orElse();
  }
}

abstract class ToggleIsFavoriteLocation implements ManageLocationsEvent {
  const factory ToggleIsFavoriteLocation(
      {required final Location locationEntity,
      required final bool isFavorite}) = _$ToggleIsFavoriteLocation;

  Location get locationEntity;
  bool get isFavorite;
  @JsonKey(ignore: true)
  _$$ToggleIsFavoriteLocationCopyWith<_$ToggleIsFavoriteLocation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddToPreviousLocationsCopyWith<$Res> {
  factory _$$AddToPreviousLocationsCopyWith(_$AddToPreviousLocations value,
          $Res Function(_$AddToPreviousLocations) then) =
      __$$AddToPreviousLocationsCopyWithImpl<$Res>;
  $Res call({Location locationEntity});

  $LocationCopyWith<$Res> get locationEntity;
}

/// @nodoc
class __$$AddToPreviousLocationsCopyWithImpl<$Res>
    extends _$ManageLocationsEventCopyWithImpl<$Res>
    implements _$$AddToPreviousLocationsCopyWith<$Res> {
  __$$AddToPreviousLocationsCopyWithImpl(_$AddToPreviousLocations _value,
      $Res Function(_$AddToPreviousLocations) _then)
      : super(_value, (v) => _then(v as _$AddToPreviousLocations));

  @override
  _$AddToPreviousLocations get _value =>
      super._value as _$AddToPreviousLocations;

  @override
  $Res call({
    Object? locationEntity = freezed,
  }) {
    return _then(_$AddToPreviousLocations(
      locationEntity: locationEntity == freezed
          ? _value.locationEntity
          : locationEntity // ignore: cast_nullable_to_non_nullable
              as Location,
    ));
  }

  @override
  $LocationCopyWith<$Res> get locationEntity {
    return $LocationCopyWith<$Res>(_value.locationEntity, (value) {
      return _then(_value.copyWith(locationEntity: value));
    });
  }
}

/// @nodoc

class _$AddToPreviousLocations implements AddToPreviousLocations {
  const _$AddToPreviousLocations({required this.locationEntity});

  @override
  final Location locationEntity;

  @override
  String toString() {
    return 'ManageLocationsEvent.addToPreviousLocations(locationEntity: $locationEntity)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddToPreviousLocations &&
            const DeepCollectionEquality()
                .equals(other.locationEntity, locationEntity));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(locationEntity));

  @JsonKey(ignore: true)
  @override
  _$$AddToPreviousLocationsCopyWith<_$AddToPreviousLocations> get copyWith =>
      __$$AddToPreviousLocationsCopyWithImpl<_$AddToPreviousLocations>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadPreviousLocations,
    required TResult Function() loadLastUsedLocation,
    required TResult Function(String locationName) searchLocation,
    required TResult Function(Location locationEntity) removeLocation,
    required TResult Function(Location locationEntity) pickPreviousLocation,
    required TResult Function(Location locationEntity, bool isFavorite)
        toggleIsFavoriteLocation,
    required TResult Function(Location locationEntity) addToPreviousLocations,
  }) {
    return addToPreviousLocations(locationEntity);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
  }) {
    return addToPreviousLocations?.call(locationEntity);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadPreviousLocations,
    TResult Function()? loadLastUsedLocation,
    TResult Function(String locationName)? searchLocation,
    TResult Function(Location locationEntity)? removeLocation,
    TResult Function(Location locationEntity)? pickPreviousLocation,
    TResult Function(Location locationEntity, bool isFavorite)?
        toggleIsFavoriteLocation,
    TResult Function(Location locationEntity)? addToPreviousLocations,
    required TResult orElse(),
  }) {
    if (addToPreviousLocations != null) {
      return addToPreviousLocations(locationEntity);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadPreviousLocations value)
        loadPreviousLocations,
    required TResult Function(LoadLastUsedLocation value) loadLastUsedLocation,
    required TResult Function(SearchLocation value) searchLocation,
    required TResult Function(RemoveLocation value) removeLocation,
    required TResult Function(PickPreviousLocation value) pickPreviousLocation,
    required TResult Function(ToggleIsFavoriteLocation value)
        toggleIsFavoriteLocation,
    required TResult Function(AddToPreviousLocations value)
        addToPreviousLocations,
  }) {
    return addToPreviousLocations(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
  }) {
    return addToPreviousLocations?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadPreviousLocations value)? loadPreviousLocations,
    TResult Function(LoadLastUsedLocation value)? loadLastUsedLocation,
    TResult Function(SearchLocation value)? searchLocation,
    TResult Function(RemoveLocation value)? removeLocation,
    TResult Function(PickPreviousLocation value)? pickPreviousLocation,
    TResult Function(ToggleIsFavoriteLocation value)? toggleIsFavoriteLocation,
    TResult Function(AddToPreviousLocations value)? addToPreviousLocations,
    required TResult orElse(),
  }) {
    if (addToPreviousLocations != null) {
      return addToPreviousLocations(this);
    }
    return orElse();
  }
}

abstract class AddToPreviousLocations implements ManageLocationsEvent {
  const factory AddToPreviousLocations(
      {required final Location locationEntity}) = _$AddToPreviousLocations;

  Location get locationEntity;
  @JsonKey(ignore: true)
  _$$AddToPreviousLocationsCopyWith<_$AddToPreviousLocations> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ManageLocationsState {
  ManageLocationStatus get manageLocationStatus =>
      throw _privateConstructorUsedError;
  Location? get currentLocation => throw _privateConstructorUsedError;
  List<Location>? get previousLocations => throw _privateConstructorUsedError;
  List<Location>? get searchResultLocations =>
      throw _privateConstructorUsedError;
  String? get errorMessage => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ManageLocationsStateCopyWith<ManageLocationsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ManageLocationsStateCopyWith<$Res> {
  factory $ManageLocationsStateCopyWith(ManageLocationsState value,
          $Res Function(ManageLocationsState) then) =
      _$ManageLocationsStateCopyWithImpl<$Res>;
  $Res call(
      {ManageLocationStatus manageLocationStatus,
      Location? currentLocation,
      List<Location>? previousLocations,
      List<Location>? searchResultLocations,
      String? errorMessage});

  $LocationCopyWith<$Res>? get currentLocation;
}

/// @nodoc
class _$ManageLocationsStateCopyWithImpl<$Res>
    implements $ManageLocationsStateCopyWith<$Res> {
  _$ManageLocationsStateCopyWithImpl(this._value, this._then);

  final ManageLocationsState _value;
  // ignore: unused_field
  final $Res Function(ManageLocationsState) _then;

  @override
  $Res call({
    Object? manageLocationStatus = freezed,
    Object? currentLocation = freezed,
    Object? previousLocations = freezed,
    Object? searchResultLocations = freezed,
    Object? errorMessage = freezed,
  }) {
    return _then(_value.copyWith(
      manageLocationStatus: manageLocationStatus == freezed
          ? _value.manageLocationStatus
          : manageLocationStatus // ignore: cast_nullable_to_non_nullable
              as ManageLocationStatus,
      currentLocation: currentLocation == freezed
          ? _value.currentLocation
          : currentLocation // ignore: cast_nullable_to_non_nullable
              as Location?,
      previousLocations: previousLocations == freezed
          ? _value.previousLocations
          : previousLocations // ignore: cast_nullable_to_non_nullable
              as List<Location>?,
      searchResultLocations: searchResultLocations == freezed
          ? _value.searchResultLocations
          : searchResultLocations // ignore: cast_nullable_to_non_nullable
              as List<Location>?,
      errorMessage: errorMessage == freezed
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  @override
  $LocationCopyWith<$Res>? get currentLocation {
    if (_value.currentLocation == null) {
      return null;
    }

    return $LocationCopyWith<$Res>(_value.currentLocation!, (value) {
      return _then(_value.copyWith(currentLocation: value));
    });
  }
}

/// @nodoc
abstract class _$$_ManageLocationsStateCopyWith<$Res>
    implements $ManageLocationsStateCopyWith<$Res> {
  factory _$$_ManageLocationsStateCopyWith(_$_ManageLocationsState value,
          $Res Function(_$_ManageLocationsState) then) =
      __$$_ManageLocationsStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {ManageLocationStatus manageLocationStatus,
      Location? currentLocation,
      List<Location>? previousLocations,
      List<Location>? searchResultLocations,
      String? errorMessage});

  @override
  $LocationCopyWith<$Res>? get currentLocation;
}

/// @nodoc
class __$$_ManageLocationsStateCopyWithImpl<$Res>
    extends _$ManageLocationsStateCopyWithImpl<$Res>
    implements _$$_ManageLocationsStateCopyWith<$Res> {
  __$$_ManageLocationsStateCopyWithImpl(_$_ManageLocationsState _value,
      $Res Function(_$_ManageLocationsState) _then)
      : super(_value, (v) => _then(v as _$_ManageLocationsState));

  @override
  _$_ManageLocationsState get _value => super._value as _$_ManageLocationsState;

  @override
  $Res call({
    Object? manageLocationStatus = freezed,
    Object? currentLocation = freezed,
    Object? previousLocations = freezed,
    Object? searchResultLocations = freezed,
    Object? errorMessage = freezed,
  }) {
    return _then(_$_ManageLocationsState(
      manageLocationStatus: manageLocationStatus == freezed
          ? _value.manageLocationStatus
          : manageLocationStatus // ignore: cast_nullable_to_non_nullable
              as ManageLocationStatus,
      currentLocation: currentLocation == freezed
          ? _value.currentLocation
          : currentLocation // ignore: cast_nullable_to_non_nullable
              as Location?,
      previousLocations: previousLocations == freezed
          ? _value._previousLocations
          : previousLocations // ignore: cast_nullable_to_non_nullable
              as List<Location>?,
      searchResultLocations: searchResultLocations == freezed
          ? _value._searchResultLocations
          : searchResultLocations // ignore: cast_nullable_to_non_nullable
              as List<Location>?,
      errorMessage: errorMessage == freezed
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_ManageLocationsState extends _ManageLocationsState {
  const _$_ManageLocationsState(
      {required this.manageLocationStatus,
      this.currentLocation,
      final List<Location>? previousLocations = const [],
      final List<Location>? searchResultLocations,
      this.errorMessage = ''})
      : _previousLocations = previousLocations,
        _searchResultLocations = searchResultLocations,
        super._();

  @override
  final ManageLocationStatus manageLocationStatus;
  @override
  final Location? currentLocation;
  final List<Location>? _previousLocations;
  @override
  @JsonKey()
  List<Location>? get previousLocations {
    final value = _previousLocations;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Location>? _searchResultLocations;
  @override
  List<Location>? get searchResultLocations {
    final value = _searchResultLocations;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey()
  final String? errorMessage;

  @override
  String toString() {
    return 'ManageLocationsState(manageLocationStatus: $manageLocationStatus, currentLocation: $currentLocation, previousLocations: $previousLocations, searchResultLocations: $searchResultLocations, errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ManageLocationsState &&
            const DeepCollectionEquality()
                .equals(other.manageLocationStatus, manageLocationStatus) &&
            const DeepCollectionEquality()
                .equals(other.currentLocation, currentLocation) &&
            const DeepCollectionEquality()
                .equals(other._previousLocations, _previousLocations) &&
            const DeepCollectionEquality()
                .equals(other._searchResultLocations, _searchResultLocations) &&
            const DeepCollectionEquality()
                .equals(other.errorMessage, errorMessage));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(manageLocationStatus),
      const DeepCollectionEquality().hash(currentLocation),
      const DeepCollectionEquality().hash(_previousLocations),
      const DeepCollectionEquality().hash(_searchResultLocations),
      const DeepCollectionEquality().hash(errorMessage));

  @JsonKey(ignore: true)
  @override
  _$$_ManageLocationsStateCopyWith<_$_ManageLocationsState> get copyWith =>
      __$$_ManageLocationsStateCopyWithImpl<_$_ManageLocationsState>(
          this, _$identity);
}

abstract class _ManageLocationsState extends ManageLocationsState {
  const factory _ManageLocationsState(
      {required final ManageLocationStatus manageLocationStatus,
      final Location? currentLocation,
      final List<Location>? previousLocations,
      final List<Location>? searchResultLocations,
      final String? errorMessage}) = _$_ManageLocationsState;
  const _ManageLocationsState._() : super._();

  @override
  ManageLocationStatus get manageLocationStatus;
  @override
  Location? get currentLocation;
  @override
  List<Location>? get previousLocations;
  @override
  List<Location>? get searchResultLocations;
  @override
  String? get errorMessage;
  @override
  @JsonKey(ignore: true)
  _$$_ManageLocationsStateCopyWith<_$_ManageLocationsState> get copyWith =>
      throw _privateConstructorUsedError;
}
